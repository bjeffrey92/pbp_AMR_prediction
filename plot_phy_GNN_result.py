import glob
import os
import pickle
from itertools import product
from typing import List, Optional

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from plot_model_fits import load_data as load_data_, process_data


def load_GNN_results(results_dir: str) -> pd.DataFrame:
    results_files = glob.glob(results_dir + "*.pkl")
    results_files = [os.path.split(i)[1] for i in results_files]
    all_results = {
        "train_pop": [],
        "test_pop_1": [],
        "test_pop_2": [],
        "metric": [],
        "score": [],
        "pop": [],
        "test_split": [],
    }
    metrics = ["mean_bin_acc", "acc", "loss"]
    populations = ["train_", "test_1_", "test_2_", "val_"]
    all_pops = ["cdc", "pmen", "maela"]
    for f in results_files:
        f = os.path.join(results_dir, f)
        with open(f, "rb") as a:
            result = pickle.load(a)
            metrics_df = result["metrics_df"]
            train_pop = result["train_population"]
            test_pop_1 = result["test_population_1"]
            test_pop_2 = list(set([train_pop, test_pop_1]) ^ set(all_pops))[0]
        for metric, pop in product(metrics, populations):
            all_results["train_pop"].append(train_pop)
            all_results["test_pop_1"].append(test_pop_1)
            all_results["test_pop_2"].append(test_pop_2)
            all_results["metric"].append(metric)
            all_results["score"].append(metrics_df[f"{pop}{metric}"].iloc[-1])
            if pop in ["train_", "val_"]:
                population = train_pop
            elif pop == "test_1_":
                population = test_pop_1
            else:
                population = test_pop_2
            all_results["pop"].append(population)
            all_results["test_split"].append(pop.replace("_", "").capitalize())
    all_results = pd.DataFrame(all_results)
    all_results.loc[all_results.metric == "mean_bin_acc", "metric"] = "mean_acc_per_bin"
    all_results.loc[all_results.metric == "acc", "metric"] = "accuracy"
    all_results.loc[all_results.metric == "loss", "metric"] = "MSE"
    all_results.loc[all_results["test_split"] == "Val", "test_split"] = "Validate"
    return all_results.rename(
        columns={
            "train_pop": "Train Population",
            "test_pop_1": "Test Population 1",
            "test_pop_2": "Test Population 2",
            "test_split": "Population",
        }
    ).assign(Model="GNN")[
        [
            "score",
            "Population",
            "Train Population",
            "Test Population 1",
            "Test Population 2",
            "Model",
            "metric",
        ]
    ]


def load_other_results(
    root_dir: str = "results",
    inference_method: str = "HMM_MIC",
    models: List[str] = ["random_forest"],
    train_populations: List[str] = ["cdc"],
) -> pd.DataFrame:
    all_metrics = [
        process_data(
            load_data_(train_pop, inference_method, root_dir=root_dir, models=models)
        )
        for train_pop in train_populations
    ]
    return pd.concat(
        [pd.concat([v.assign(metric=k) for k, v in i.items()]) for i in all_metrics]
    )


def plot_metric(all_results: pd.DataFrame, metric: str = "mean_acc_per_bin"):
    results = all_results.loc[all_results.metric == metric]
    plt.clf()
    fig = plt.figure()
    for i, (_, df) in enumerate(
        results.groupby(["Train Population", "Test Population 1"])
    ):
        ax = fig.add_subplot(3, 2, i + 1)
        sns.barplot(
            data=df,
            x="Population",
            y="score",
            hue="Model",
            ax=ax,
        )
        if i % 2 == 1:
            plt.ylabel("")
        if i < 4:
            plt.xlabel("")
        ax.get_legend().remove()


def _load_theoretical_max_data(metrics: pd.DataFrame, results_dir: str) -> pd.DataFrame:
    # generated by max_expected_mab function in plot_mic_dist_per_sequence.py
    max_expected_MAB = pd.read_csv(os.path.join(results_dir, "max_expected_MAB.csv"))

    return metrics.merge(
        max_expected_MAB, on=["Population", "Test Population 1"], how="outer"
    )


def single_pop_plot_metric(
    all_results: pd.DataFrame,
    metric: str = "mean_acc_per_bin",
    ylab: str = "Mean Accuracy per Bin",
    pop: str = "cdc",
    plot_theoretical_max: bool = False,
    results_dir: Optional[str] = None,
):
    results = all_results.loc[
        (all_results.metric == metric) & (all_results["Train Population"] == pop)
    ]
    results.loc[results.Model == "random_forest", "Model"] = "Random Forest"
    results = results.rename(columns={"score": ylab})

    if plot_theoretical_max:
        results = _load_theoretical_max_data(results, results_dir)

    results = results.assign(
        **{
            "Test Population 1": results["Test Population 1"]
            .str.replace("pmen", "PMEN")
            .str.replace("maela", "Maela")
        }
    )

    plt.clf()
    plt.rcParams.update({"font.size": 16})
    results = results.rename(columns={"score": "Mean Accuracy per Bin"})
    g = sns.catplot(
        data=results,
        x="Population",
        y="Mean Accuracy per Bin",
        hue="Model",
        col="Test Population 1",
        kind="bar",
        order=["Train", "Validate", "Test1", "Test2"],
    )
    if plot_theoretical_max:
        g.map_dataframe(
            sns.stripplot,
            x="Population",
            y="max_expected_MAB",
            hue="Model",
            color="black",
            jitter=False,
            marker="D",
            order=["Train", "Validate", "Test1", "Test2"],
        )
        g.set_axis_labels(x_var="Population", y_var="Mean Accuracy per Bin")
        g.fig.subplots_adjust(bottom=0.15, left=0.1)
    g.set(ylim=[0, 100])


if __name__ == "__main__":
    GNN_results = load_GNN_results(
        "results/maela_updated_mic_rerun/phylogeny_GNN_model/hamming_dist_tree/"
    )
    other_model_results = load_other_results(
        "results/maela_updated_mic_rerun",
        inference_method="no_inference",
        models=["random_forest", "interaction_models"],
    )
    all_results = pd.concat([GNN_results, other_model_results])
    for train_pop in all_results["Train Population"].drop_duplicates():
        single_pop_plot_metric(
            all_results,
            pop=train_pop,
            plot_theoretical_max=True,
            results_dir="results/maela_updated_mic_rerun/",
        )
        plt.savefig(f"GNN_vs_RF_train_pop_{train_pop}.png")
